# Текущие комментарии и вопросы

Описание задачи и алгоритма [тут](README.md)

## Наблюдения

Выводы о самой программе и особенностях разработки на Haskell.

1. Программа значительно короче и экспресивнее, чем на питоне, но 
  версия на питоне помогла разобраться с особенностями данных.

   - Пример: для рабора файла на таблицы в питоне использовалась 
     state machine, которая занимала целый модуль и кучу 
     вспомогательных типов данных и переменных (стеки, флаги и т.д.) и 
     естественно циклы. Сейчас это 5-7 строчек функционального кода.
     Справдливости ради: сейчас реализван другой, более простой алгоритм
     разбора на таблицы, до которого вряд ли можно было сразу додуматься 
     до state machine. 
     Еще ради справдливости: когда пишешь на питоне в сторону простого 
     алгоритма и не думаешь.

2. В питоне, даже зная о пользе разделения программы на независымые куски все равно     
   получается некий монолит. Haskell заставляет перейти к более блочной структуре
   программы, где выполняется какой-то кусок обработки данных и затем передается 
   другой программе в виде текстового stdout или файла. 

   - Пример: помучавшись с типами, я понял что привожу данные к списку кортежей
     `[(String, Char, Int, String)]` причем `String` (или `ByteString`) - это данные 
     из файла, а `Char, Int` - результат парсинга. Одновременно с этим открытием
     я понял что могу отложить обрабтку `String` (например,  `101,61)2)` -> `101.6`)
     и сделать ее либо вообще вне программы, либо отдельным фильтром. 

3. Приходит понимание, что в программе есть часть ввода-вывода   
  данных ("монадическая") и сама библиотека парсинга (на чистых функциях). 
  Часть с вводом-выводом пока немного напрягаяет,
  а писать на чистых функциях довольно комфортно. Ввод-вывод сейчас это
  `Main.hs`, чистая библиотека `Table/Table.hs`. 


4. Также приходит понимание, что в Haskell уровни абстракции  - это тип данных и связанные с ними функции, например:
  - плоский файл, `String` или `ByteString`
  - после чтения как CSV - строки файла, разбитые разделителями `[[String]]`
  - в процессе парсинга таблиц `[ DataRow [String] | TextRow [String] ]`
  - после создания таблиц - `[Table [String] [String]]`
  - после получения данных `[Value]`
  - готовый результат `Variable`
  - иногда возникают Maybe и Either, но я пока из них быстро выхожу.
   
5. При этом слишком много уровней абстракции данных усложняют тестирование, поэтому с ними приходится расставаться в пользу более простых конструктуров. 
   
  - Пример: сначала получался тип `Table (TextRow [String]) (DataRow [String])`, 
    но создавать данные для тестов таким сложными конструктуорами - замучаешься.
    В результате типы `DataRow` и `TextRow` используются только на стадии 
    разбора файла на таблицы, а я из них выхожу. Хотелось бы  комментарий, оправдано ли это.

6. Небольшой опыт - возможности компилятора правильно определить подпись функции 
   зависят от того, где эта функция находится. 

   - Пример: я выносил функции чтения и записи файлов в File.hs вместо Main.hs
     и в этом случае компилятор не понимал какие у них типы. Пока все вместе лежит 
     в Main.hs все отлично.   

## Что получилось

- Программа читает фиксированный файл `gdp.txt` и пишет `gdp.csv`
- Умеем получать данные из таблиц, где в заголовке есть и название переменной,
  и размерность
- Словари для парсинга заголовков hardcoded в отдельном модуле `Map.hs` (может быть
  внешним файлом JSON, но пока надежнее так) 

## Вопросы 

1. **Vector / ByteString**. Сейчас, видимо, есть потеря в скорости и читаемости из-за 
  того что `Data.CSV`  выдает результат  в формате `V.Vector (V.Vector ByteString)`, а модуль `Table`  работает с `[[String]]` - проще примеры для тестов писать в виде обычных строк.  Куда двигаться - оставить `toStrings` в загрузке CSV или менять тесты на испоьзование `ByteString`?

```
  type ByteStringMatrix = V.Vector (V.Vector BL.ByteString)
  toStrings :: Either String ByteStringMatrix -> [[String]]
```

  Может есть какая-то директива компилятора считать `"аbс" :: String` тоже `ByteString`?
  Возможно `-XOverloadedStrings extension`?

  На всякий случай ввел тип `type LocalString = String`, чтобы при необходимости заменить на `ByteString`

2. Сделал отдельный модуль со всеми новыми типами - Type.hs корне (`Table`, `RowFormat` и    тд.). Практикуется ли обычно такое?
  
3. Есть опасение, что весь парсинг может быть какой-то сложной монадой. Правда ли
   это? 

4. Есть ли профайлер в Хаскелле? Как посомтреть где программа проводит больше времени?

5. Сколько раз вызовется `asText label` - один раз или много? Как сделать чтобы один?

``` 
getValues :: Variable -> [DataTuple]
getValues (Variable label values) = [(s, y, f, p, x) | (Value y f p x) <- values]
    where s = asText label
```    

Аналогичный вопрос: здесь t вызовется один или два раза? Если два раза, то как сделать один?

```
tableLabel :: Table -> Label
tableLabel t = let s = title t in Label (getName s) (getUnit s)     
``` 

## Что не получается 

- Наладить тестирование (директивы Cabal и сами тесты HUnit и QuickCheck). 
  Очень хотелось бы 1-2 текста запустить. Сейчас тестом является запуск 
  `Table/Table.hs` и `Main.hs`

## Что делать дальше

- Читать реальные данные [tab.csv](https://raw.githubusercontent.com/mini-kep/parser-rosstat-kep/dev/data/interim/2018/07/tab.csv)

- Посмотреть https://github.com/docopt/docopt.hs для опций типа
  ```kep.exe tab.csv --definition=special.toml --no-empty-cells > output.csv```

- Импортровать Map.hs из TOML файла (позволит добавить другие опции парсинга)
