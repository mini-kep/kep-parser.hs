# Текущие комментарии и вопросы

Описание задачи и алгоритма [тут](README.md)

## Наблюдения

Выводы о самой программе и особенностях разработки на Haskell.

1. Программа значительно короче и экспресивнее, чем на питоне, но 
  версия на питоне помогла разобраться с особенностями данных.

   - Пример: для рабора файла на таблицы в питоне использовалась 
     state machine, которая занимала целый модуль и кучу 
     вспомогательных типов данных и переменных (стеки, флаги и т.д.) и 
     естественно циклы. Сейчас это 5-7 строчек функционального кода.
     Справдливости ради: сейчас реализван другой, более простой алгоритм
     разбора на таблицы, до которого вряд ли можно было сразу додуматься 
     до state machine. 
     Еще ради справдливости: когда пишешь на питоне в сторону простого 
     алгоритма и не думаешь.

2. В питоне, даже зная о пользе разделения программы на независымые куски все равно     
   получается некий монолит. Haskell заставляет перейти к более блочной структуре
   программы, где выполняется какой-то кусок обработки данных и затем передается 
   другой программе в виде текстового stdout или файла. 

   - Пример: помучавшись с типами, я понял что привожу данные к списку кортежей
     `[(String, Char, Int, String)]` причем `String` (или `ByteString`) - это данные 
     из файла, а `Char, Int` - результат парсинга. Одновременно с этим открытием
     я понял что могу отложить обрабтку `String` (например,  `101,61)2)` -> `101.6`)
     и сделать ее либо вообще вне программы, либо отдельным фильтром. 

3. Приходит понимание, что в программе есть часть ввода-вывода   
  данных ("монадическая") и сама библиотека парсинга (на чистых функциях). 
  Часть с вводом-выводом пока немного напрягаяет из-за `IO ()`,
  а писать на чистых функциях довольно комфортно. Ввод-вывод сейчас это
  `Main.hs`, чистая библиотека `Table/Table.hs`. В библиотеке
  всего две публичные функции `makeTables :: [[String]] -> [Table]` и `getValues :: [Table] -> [Value]`.


4. Не знаю как лучше объяснить, но в Haskell лучше получается выстроить 
  уровни абстракции данных, например:
  - плоский файл, `String` или `ByteString`
  - после чтения как CSV - строки файла, разбитые разделителями `[[String]]`
  - в процессе парсинга таблиц `[ DataRow [String] | TextRow [String] ]`
  - после создания таблиц - `[Table [String] [String]]`
  - после получения данных `[Value]`
  - иногда возникают Maybe и Either, но я пока из них быстро выхожу
  
5. При этом слишком много уровней абстракции данных усложняют тестирование, поэтому с ними приходится расставаться в пользу более простых конструктуров. 
   
  - Пример: сначала получался тип `Table (TextRow [String]) (DataRow [String])`, 
    но создавать данные для тестов таким сложными конструктуорами - замучаешься.
    В результате типы `DataRow` и `TextRow` используются только на стадии 
    разбора файла на таблицы, а я из них выхожу. Хотелось бы  комментарий, оправдано ли это.

6. Небольшой опыт - возможности компилятора правильно определить подпись функции 
   зависят от того, где эта функция находится. 

   - Пример: я выносил функции чтения и записи файлов в File.hs вместо Main.hs
     и в этом случае компилятор не понимал какие у них типы. Пока все вместе лежит 
     в Main.hs все отлично.   

## Что получилось

- Программа читает фиксированный файл `gdp.txt` и пишет `gdp.csv`
- Умеем получать данные из таблиц, где в заголовке есть и название переменной,
  и размерность
- Словари для парсинга заголовков hardcoded в отдельном модуле `Map.hs` (может быть
  внешним файлом JSON, но пока надежнее так) 

## Вопросы 

1. **Vector / ByteString**. Сейчас, видимо, есть потеря в скорости и читаемости из-за 
  того что `Data.CSV`  выдает результат  в формате `V.Vector (V.Vector ByteString)`, а модуль `Table`  работает с `[[String]]` - проще примеры для тестов писать в виде обычных строк.  Куда двигаться - оставить `toStringы`::  или менять тесты на испоьзование `ByteString`?

```
  type ByteStringMatrix = V.Vector (V.Vector BL.ByteString)
  toStrings :: Either String ByteStringMatrix -> [[String]]
```

  Может есть какая-то директива компилятора считать `"аbс" :: String` тоже `ByteString`?
  Возможно `-XOverloadedStrings extension`?

2. Немного чешутся руки сделать отдельный модуль со всеми новыми типами - Type.hs
   в корне (`Table`, `RowFormat`). Позволяет избежать циклических импортов. Практикуется ли такое?
  
3. Есть опасение, что весь парсинг может быть какой-то сложной монадой. Правда ли
   это? 

## Что не получается 

- Наладить тестирование (директивы Cabal и сами тесты HUnit и QuickCheck).

## Что делать дальше

- Читать реальные данные [tab.csv](https://raw.githubusercontent.com/mini-kep/parser-rosstat-kep/dev/data/interim/2018/07/tab.csv)

